/**
 * @fileOverview Firestore Security Rules for OrderFlow Application
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-specific data (notifications)
 * and leverages denormalized access control lists for collaborative resources (chat channels).
 * It prioritizes authorization independence to minimize `get()` calls and improve performance.
 *
 * Data Structure:
 * - /customers/{customerId}: Stores customer profiles. Accessible to authenticated users.
 * - /orders/{orderId}: Stores order information. Accessible to authenticated users.
 * - /chatChannels/{chatChannelId}: Stores chat channels. Access controlled by the 'participants' array.
 * - /chatChannels/{chatChannelId}/messages/{messageId}: Stores chat messages. Access inherited from the parent channel.
 * - /users/{userId}/notifications/{notificationId}: Stores user-specific notifications. Owner-only access.
 * - /users/{userId}: Stores user profiles. Owner-only access.
 *
 * Key Security Decisions:
 * - User listing is implicitly denied by the rules structure.
 * - All write operations require authentication.
 * - Data validation is relaxed for rapid prototyping, focusing on authorization and relational integrity.
 *
 * Denormalization for Authorization:
 * - ChatChannel documents include a 'participants' array containing user IDs who have access. This avoids needing to query a separate membership collection.
 *
 * Structural Segregation:
 * - User-specific notifications are stored in a private subcollection under /users/{userId} to ensure only the owner can access them.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Customer profiles. Accessible to authenticated users.
     * @path /customers/{customerId}
     * @allow (get, list): Any authenticated user can read customer profiles.
     * @allow (create, update, delete): Only authenticated users can modify customer profiles.
     * @deny (create, update, delete): An unauthenticated user cannot modify customer profiles.
     * @principle Allows authenticated users to read customer profiles.
     */
    match /customers/{customerId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Order information. Accessible to authenticated users.
     * @path /orders/{orderId}
     * @allow (get, list): Any authenticated user can read order information.
     * @allow (create, update, delete): Only authenticated users can modify order information.
     * @deny (create, update, delete): An unauthenticated user cannot modify order information.
     * @principle Allows authenticated users to read order information.
     */
    match /orders/{orderId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Chat channels. Access controlled by the 'participants' array.
     * @path /chatChannels/{chatChannelId}
     * @allow (get): User is a participant in the chat channel.
     * @allow (list): User is authenticated.
     * @allow (create): User is a participant in the chat channel.
     * @allow (update): User is an existing participant in the chat channel. Only participants can update the channel.
     * @allow (delete): User is an existing participant in the chat channel. Only participants can delete the channel.
     * @deny (create, update, delete): User is not a participant.
     * @principle Enforces access control based on the 'participants' array in the ChatChannel document.
     */
    match /chatChannels/{chatChannelId} {
      allow get: if isSignedIn() && isParticipant(resource.data.participants);
      allow list: if isSignedIn();
      allow create: if isSignedIn() && isNewParticipant(request.resource.data.participants);
      allow update: if isSignedIn() && isExistingParticipant(resource.data.participants);
      allow delete: if isSignedIn() && isExistingParticipant(resource.data.participants);
    }

    /**
     * @description Chat messages within a channel.
     * @path /chatChannels/{chatChannelId}/messages/{messageId}
     * @allow (get, list): User is a participant in the parent chat channel.
     * @allow (create): User is a participant in the parent chat channel.
     * @allow (update, delete): User is the sender of the message and a participant in the parent chat channel.
     * @deny (create, update, delete): User is not a participant in the parent chat channel.
     * @principle Inherits access control from the parent ChatChannel document.
     */
    match /chatChannels/{chatChannelId}/messages/{messageId} {
      allow get, list: if isSignedIn() && isChatMessageParticipant(chatChannelId);
      allow create: if isSignedIn() && isChatMessageParticipant(chatChannelId);
      allow update: if isSignedIn() && isChatMessageSender(chatChannelId, resource.data.senderId) ;
      allow delete: if isSignedIn() && isChatMessageSender(chatChannelId, resource.data.senderId);
    }

    /**
     * @description User-specific notifications. Owner-only access.
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (get, list): User ID matches the authenticated user ID.
     * @allow (create): User ID matches the authenticated user ID.
     * @allow (update, delete): User ID matches the authenticated user ID and the notification exists.
     * @deny (create, update, delete): User ID does not match the authenticated user ID.
     * @principle Enforces strict user ownership for notifications.
     */
    match /users/{userId}/notifications/{notificationId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isExistingOwner(userId) && resource.data.userId == userId;
    }

    /**
     * @description User profiles. Owner-only access.
     * @path /users/{userId}
     * @allow (get): User ID matches the authenticated user ID.
     * @allow (create): User ID matches the authenticated user ID. Allows user self-creation.
     * @allow (update, delete): User ID matches the authenticated user ID and the user exists.
     * @deny (create, update, delete): User ID does not match the authenticated user ID.
     * @principle Enforces strict user ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(userId) && resource.data.id == userId;
      allow delete: if isExistingOwner(userId) && resource.data.id == userId;
    }

    // --- Helper Functions ---

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner of the resource.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is the owner of the resource and the resource exists.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     * @return {boolean} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the user is a participant in the chat channel.
     * @param {array} participants An array of user IDs who are participants in the chat channel.
     * @return {boolean} True if the user is a participant, false otherwise.
     */
    function isParticipant(participants) {
        return isSignedIn() && participants.hasAny([request.auth.uid]);
    }

      /**
       * @description Checks if the user is a NEW participant in the chat channel for create operation.
       * @param {array} participants An array of user IDs who are participants in the chat channel.
       * @return {boolean} True if the user is a participant, false otherwise.
       */
    function isNewParticipant(participants) {
      return isSignedIn() && participants.hasAny([request.auth.uid]);
    }


    /**
     * @description Checks if the user is an EXISTING participant in the chat channel.
     * @param {array} participants An array of user IDs who are participants in the chat channel.
     * @return {boolean} True if the user is a participant, false otherwise.
     */
    function isExistingParticipant(participants) {
        return isSignedIn() && resource != null && participants.hasAny([request.auth.uid]);
    }

    /**
     * @description Checks if the user is a participant in the chat channel, using a `get()` request.
     * @param {string} chatChannelId The ID of the chat channel.
     * @return {boolean} True if the user is a participant, false otherwise.
     */
    function isChatMessageParticipant(chatChannelId) {
      return get(/databases/$(database)/documents/chatChannels/$(chatChannelId)).data.participants.hasAny([request.auth.uid]);
    }

    /**
     * @description Checks if the user is the sender of the chat message and a participant in the chat channel, using a `get()` request.
     * @param {string} chatChannelId The ID of the chat channel.
     * @param {string} senderId The ID of the message sender
     * @return {boolean} True if the user is the sender, false otherwise.
     */
    function isChatMessageSender(chatChannelId, senderId) {
      return request.auth.uid == senderId && get(/databases/$(database)/documents/chatChannels/$(chatChannelId)).data.participants.hasAny([request.auth.uid]);
    }
  }
}